/******************************************************

[Pointer]
- 주소를 저장하는 변수
- 기존의 변수는 데이터를 저장하는데 반하여 포인터는 메모리 공간의 주소를 저장.
- 포인터 변수가 주소를 저장하려면 변수의 주소를 알아야 함.
- 변수 이름 앞에 & 연산자를 붙이면 해당 변수의 시작 주소를 반환.
- 또한, 포인터 변수가 저장하는 변수의 주소에 저장된 값을 참조하려면 * 연산자를 이용.

[포인터 연산자]
&: 특정한 데이터의 메모리 상의 주소 값을 알 수 있다.
*: & 연산자가 어떠한 데이터의 주소 값을 얻어내는 연산자라면,
   거꾸로 주소 값에서 해당 주소 값에 대응되는 데이터를 가져오는 연산자가 필요.

[포인터 정의 방법]
(포인터에 주소 값이 저장되는 데이터형)* (포인터의 이름)

[왜 타입이 있을까?]
- 만약 포인터라는 타입이 있다면
int a;
Pointer* p;
p = &a;

p는 a의 주소 값이 저장됨.
문제는 a가 메모리에서 차지하는 모든 주소들의 위치가
들어가있는 것이 아닌 시작 주소만 들어있음.

즉, 컴퓨터가 메모리에 얼마만큼 읽어들여야 할지 알 방법이 없음.


******************************************************/

#include <iostream>

int main()
{
	//int* p;

	//int a;
	//a = 2;
	//p = &a;		// 변수 a의 주소를 포인터 변수 p에 저장

	//std::cout << "p의 값(a의 주소): " << p << std::endl;
	//std::cout << "변수 a의 주소 값: " << &a << std::endl;

	//std::cout << "*p의 값(a에 저장된 데이터): " << *p << std::endl;
	//std::cout << "포인터 변수 p의 주소 값: " << &p << std::endl;

	//// 역참조
	//*p = 555;
	//std::cout << "역참조 후 변수 a에 저장된 데이터: " << a << std::endl;

	int num = 10;
	int* p = &num;

	int** pp;

	// Error
	// pp = &num;
	
	// 포인터의 주소를 저장
	pp = &p;

	std::cout << "pp의 값(포인터 변수 p의 주소 값): " << pp << std::endl;
	
	**pp = 1234;
	std::cout << "num: " << num << std::endl;
	
	// null 포인터로 초기화 -> 안정성을 위함.
	// int* ptr = nullptr;

	// 동적 Heap Memory에 할당
	// ptr은 동적 메모리에 할당된 주소를 가리키고 있음.
	int* ptr = new int(42);

	std::cout << "동적 할당된 값: " << *ptr << std::endl;

	// 할당한 것을 수동 해제
	delete ptr;

	// 댕글링 포인터: 메모리에서 이미 해제된 위치를 가리키는 포인터
	std::cout << "해제 후 ptr의 주소: " << ptr << std::endl;

	ptr = nullptr;
	std::cout << "널포인터로 안전하게: " << ptr << std::endl;

	return 0;
}