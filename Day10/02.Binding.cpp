/*************************************

[정적 바인딩 VS 동적 바인딩]
- 바인딩: 함수가 호출될 때 함수의 주소를 연결

1. 정적 바인딩
- 컴파일 타임에 함수 호출이 어떤 함수와 연결될 지 결정하는 방식
- 컴파일 타임에 결정되기 때문에 실행 속도 빠름.
- 이미 컴파일하는 타임에 모든 것이 결정되기 때문에 런타임 성능에 영향을 미치지 않음.

2. 동적 바인딩
- 가상 함수와 가상 함수 테이블과 관련이 있음.
- 런 타임에 함수 호출이 어떤 함수로 연결될 지 결정하는 방식
  -> 바인딩을 실행 시간에 결정하도록 미뤄놨다가 호출 시 결정
- 오버라이딩된 가상 함수를 동적으로 찾아 호출.
- 실행 중에 결정이 되기 때문에 상대적으로 오버헤드가 발생될 수 있음.
- 아딴 포인터에 의해 접근되었는지와 상관없이 참조된 인스턴스의 실제 클래스형에 따라
  재정의된 함수 호출 가능

[VTable]
- 가상 함수 테이블은 각 클래스가 가지고 있는 가상 함수에 대한 포인터를 저장하는 테이블
- 각 클래스는 자신만의 가상 함수 테이블을 가지고 있으며, 테이블은 해당 클래스의
  가상 함수들이 메모리에 어느 위치에 있는지 가리키게 됨.
- 객체가 생성될 때 해당 객체는 그 클래스의 가상 함수 테이블을 가리키는 포인터를 가지며,
  런 타임에 적절한 함수가 호출됨.

*************************************/

#include <iostream>

class A
{
public:
	void Print(int i)
	{
		std::cout << "int형 매개변수 Print 함수 " << i << std::endl;
	}

	void Print(double d)
	{
		std::cout << "double형 매개변수 Print 함수 " << d << std::endl;

	}
};

class Parent
{
public:
	virtual void Show()const
	{
		std::cout << "부모" << std::endl;
	}
};

class Child : public Parent
{
public:
	void Show()const override
	{
		std::cout << "부모" << std::endl;
	}
};

int main()
{
	// 정적 바인딩
	A a;
	a.Print(10);
	a.Print(1.5);

	// 동적 바인딩
	Parent* p = new Child();	// 부모 클래스 포인터가 자식을 가리킴
	p->Show();
}